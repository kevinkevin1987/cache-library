# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d2eNRz7q9gVx1kDLhrwCQLCjlEE3mkKR
"""

import time                                 #for timing
from threading import RLock                 #for preventing other thread using same variables
from collections import OrderedDict         #for max len setting

class CacheLibrary(OrderedDict):
    def __init__(self, max_len, timer):
        OrderedDict.__init__(self)
        """ To make suire the input is correct to prevent errors.
        Raise assertion error if criteria not fulfilled  
        """
        assert max_len >= 1                 #make max_len is at least 1
        assert max_len % 1 == 0             #make sure if full integer number
        assert timer >= 0                   #make sure timer is positive
        self.max_len = max_len
        self.timer = time.time() + timer    #countdown
        self.lock = RLock()                 #prevent variable being use while a thread is running

    def __setitem__(self, key, value):
        """ Set cache[key] to value. """
        with self.lock:
            if len(self) == self.max_len:
                if key in self:
                    del self[key]
                else:
                    try:
                        self.popitem(last=False)
                    except KeyError:
                        pass
            if type(value)==tuple:
                seconds = time.time() + value[1]
                if seconds > self.timer:
                    seconds = self.timer
                OrderedDict.__setitem__(self, key, (value[0], seconds))
            else:
                seconds = self.timer
                OrderedDict.__setitem__(self, key, (value, seconds))

    def __getitem__(self, key, with_age=False):
        """ Return the items of the dictionary.
        return False if key is not in the dictionary.
        """
        if time.time() > self.timer:
            self.clear()
            return False
        try:    
            with self.lock:
                temp = OrderedDict.__getitem__(self, key)
                temp_seconds = temp[1] - time.time() 
                if temp_seconds > 0:
                    return temp[0], temp_seconds
                else:
                    del self[key]
                    return False
        except KeyError:
            return False


    def contains(self, key):
        """ Return True if the dictionary has the key, else return False. """
        with self.lock:
            if self.__getitem__(key) == False:
                return False
            else:
                return True

    def pop(self, key, default=None):
        """ Get item from the dictionary and remove it.
        Return the item removed if successful.
        Return False if the item not in the dictionary.
        """
        with self.lock:
            temp = OrderedDict.__getitem__(self, key)
            if temp == False:
                return False
            else:
                del self[key]
                return temp

    def get(self, key, default=None, with_age=False):
        """ Create function get. """
        return self.__getitem__(key, with_age)


    def ttl(self, key):
        """ Return time to live (ttl) of the key in seconds.
        Returns False if key not in dictionary.
        """
        if self.get(key, with_age=True) != False:
            temp_value, temp_time = self.get(key, with_age=True)
            return temp_time
        else:
            return False

    def CacheValues(self):
        """ Return dictionary list of (key, value) """
        temp = []
        for key in self.keys():
            if self.ttl(key) > 0:
                temp.append((key,self.__getitem__(key)[0]))
        return temp

    def CacheValuesTime(self):
        """ Return dictionary list of (key, value, time left) """
        temp = []
        for key in self.keys():
            if self.ttl(key) > 0:
                temp.append((key,self.__getitem__(key)))
        return temp